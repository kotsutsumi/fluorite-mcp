import { Command } from 'commander';
import * as fs from 'fs/promises';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import { ClaudeDetector } from '../utils/claude-detector.js';
import { ClaudePaths } from '../utils/paths.js';
import { SuperClaudeCommands } from '../data/superclaude-commands.js';

const execAsync = promisify(exec);

export const setupCommand = new Command('setup')
  .description('Setup fluorite-mcp with Claude Code CLI')
  .option('--force', 'Force setup even if already configured')
  .option('--dry-run', 'Show what would be done without making changes')
  .action(async (options) => {
    console.log('üöÄ Setting up fluorite-mcp with Claude Code CLI...\n');

    try {
      // Step 1: Detect Claude Code CLI
      console.log('1. Detecting Claude Code CLI installation...');
      const claude = await ClaudeDetector.detect();
      
      if (!claude.installed) {
        console.error('‚ùå Claude Code CLI not found. Please install it first:');
        console.error('   npm install -g @anthropic/claude-code-cli');
        process.exit(1);
      }
      
      console.log(`‚úÖ Claude Code CLI detected (${claude.version})`);
      
      if (!claude.mcpSupported) {
        console.warn('‚ö†Ô∏è  MCP support not detected. Please update Claude CLI.');
      }

      // Step 2: Ensure configuration directories exist
      console.log('\n2. Creating configuration directories...');
      if (!options.dryRun) {
        await ClaudeDetector.ensureClaudeConfig();
      }
      console.log(`‚úÖ Configuration directories ready`);

      // Step 3: Register MCP server
      console.log('\n3. Registering fluorite-mcp as MCP server...');
      if (!options.dryRun) {
        try {
          await execAsync('claude mcp add fluorite -- fluorite-mcp-server');
          console.log('‚úÖ MCP server registered');
        } catch (error) {
          console.log('‚ÑπÔ∏è  MCP server already registered or registration failed');
        }
      } else {
        console.log('üìã Would run: claude mcp add fluorite -- fluorite-mcp-server');
      }

      // Step 4: Create fluorite commands configuration
      console.log('\n4. Creating fluorite command configurations...');
      if (!options.dryRun) {
        await createFluoriteCommands();
        await updateClaudeCommands(options.force);
        await createCommandExecutors();
        await createClaudeSlashCommands();
      } else {
        console.log('üìã Would create fluorite command configurations');
      }
      console.log('‚úÖ Command configurations created');

      // Step 5: Verify installation
      console.log('\n5. Verifying installation...');
      await verifyInstallation(options.dryRun);

      console.log('\nüéâ Setup completed successfully!');
      console.log('\nYou can now use /fl: commands in Claude Code CLI:');
      console.log('  /fl:git commit,push');
      console.log('  /fl:analyze --focus architecture');
      console.log('  /fl:implement "create REST API"');
      console.log('\nFor help: /fl:help');

    } catch (error) {
      console.error(`\n‚ùå Setup failed: ${error}`);
      process.exit(1);
    }
  });

async function createFluoriteCommands(): Promise<void> {
  const config = {
    version: '1.0.0',
    commands: SuperClaudeCommands.getAll(),
    setup_date: new Date().toISOString()
  };

  const configYaml = `# Fluorite MCP Configuration
version: 1.0.0
setup_date: ${config.setup_date}

# Command mappings from /fl: to /sc:
commands:
${config.commands.map(cmd => `  - fluorite: "/fl:${cmd.name}"
    superclaude: "/sc:${cmd.name}"
    description: "${cmd.description}"
    enhanced: true`).join('\n')}

# MCP Integration
mcp:
  server: fluorite-mcp
  enabled: true
  
# Performance
cache:
  enabled: true
  ttl: 3600
`;

  await fs.writeFile(ClaudePaths.fluoriteConfig, configYaml, 'utf8');
}

async function createCommandExecutors(): Promise<void> {
  // Create shell script wrapper for each command
  const wrapperScript = `#!/bin/bash
# Fluorite command executor
# Automatically generated by fluorite-mcp setup

COMMAND="\$1"
shift
ARGS="\$@"

# Extract the fl: command name
if [[ "\$COMMAND" =~ ^/fl:(.+)$ ]]; then
  FL_COMMAND="\${BASH_REMATCH[1]}"
  
  case "\$FL_COMMAND" in
    "help")
      # Use the fluorite CLI for help
      if command -v fluorite-mcp >/dev/null 2>&1; then
        fluorite-mcp fl-help \$ARGS
      else
        echo "Fluorite Commands (SuperClaude Wrapper)"
        echo ""
        echo "Available /fl: commands:"
        echo "  /fl:build        - Project builder with framework detection"
        echo "  /fl:implement    - Feature and code implementation"
        echo "  /fl:analyze      - Multi-dimensional code and system analysis"
        echo "  /fl:improve      - Evidence-based code enhancement"
        echo "  /fl:git          - Git workflow assistant"
        echo "  /fl:test         - Testing workflows and validation"
        echo "  /fl:document     - Documentation generation"
        echo "  /fl:spike        - Spike template operations"
        echo ""
        echo "Usage: /fl:[command] [arguments] [flags]"
        echo "All commands are enhanced versions of SuperClaude /sc: commands"
      fi
      ;;
    "spike")
      # Handle spike operations through MCP server
      if command -v fluorite-mcp-server >/dev/null 2>&1; then
        fluorite-mcp-server spike \$ARGS
      else
        echo "‚ùå Fluorite MCP server not found. Please ensure fluorite-mcp is properly installed."
        exit 1
      fi
      ;;
    *)
      # Map to SuperClaude command with fluorite enhancement
      echo "üîÆ Fluorite: Executing /fl:\$FL_COMMAND ‚Üí /sc:\$FL_COMMAND with enhancements..."
      
      # Add fluorite-specific preprocessing flags
      ENHANCED_ARGS="--persona-smart --token-optimize --spike-aware \$ARGS"
      
      # Execute as SuperClaude command through Claude CLI
      if command -v claude >/dev/null 2>&1; then
        exec claude "/sc:\$FL_COMMAND" \$ENHANCED_ARGS
      else
        echo "‚ùå Claude CLI not found. Please ensure Claude Code CLI is installed."
        echo "   Install with: npm install -g @anthropic/claude-code-cli"
        exit 1
      fi
      ;;
  esac
else
  echo "Invalid fluorite command format. Use /fl:[command] [args]"
  exit 1
fi
`;

  const executorPath = path.join(ClaudePaths.fluoriteDir, 'executor.sh');
  await fs.writeFile(executorPath, wrapperScript, 'utf8');
  
  // Make executable
  try {
    const { exec } = await import('child_process');
    const { promisify } = await import('util');
    const execAsync = promisify(exec);
    await execAsync(`chmod +x "${executorPath}"`);
  } catch (error) {
    console.warn('‚ö†Ô∏è  Could not set execute permissions on wrapper script');
  }
}

async function createClaudeSlashCommands(): Promise<void> {
  // Create slash command definitions that Claude CLI can recognize
  const executorPath = path.join(ClaudePaths.fluoriteDir, 'executor.sh');
  
  // Create command definitions for each fluorite command
  const commandDefs = SuperClaudeCommands.getAll().map(cmd => {
    return {
      command: `/fl:${cmd.name}`,
      description: cmd.description,
      category: cmd.category,
      executor: executorPath,
      mapping: `/sc:${cmd.name}`,
      enhanced: true
    };
  });

  // Add special commands
  commandDefs.push(
    {
      command: '/fl:help',
      description: 'Show help for fluorite commands',
      category: 'Meta',
      executor: 'fluorite-mcp fl-help',
      mapping: 'direct',
      enhanced: false
    },
    {
      command: '/fl:spike',
      description: 'Spike template operations',
      category: 'Spike',
      executor: 'fluorite-mcp-server spike',
      mapping: 'direct',
      enhanced: false
    }
  );

  // Write command definitions
  const commandsYaml = `# Fluorite Slash Commands for Claude CLI
# Generated by fluorite-mcp setup

version: 1.0.0
executor: "${executorPath}"

commands:
${commandDefs.map(cmd => `  - name: "${cmd.command}"
    description: "${cmd.description}"
    category: "${cmd.category}"
    executor: "${cmd.executor}"
    mapping: "${cmd.mapping}"
    enhanced: ${cmd.enhanced}`).join('\n')}

# Integration settings
integration:
  superclaude_prefix: "/sc:"
  fluorite_prefix: "/fl:"
  auto_enhance: true
  spike_templates: true
  token_optimize: true
`;

  const slashCommandsPath = path.join(ClaudePaths.fluoriteDir, 'slash-commands.yaml');
  await fs.writeFile(slashCommandsPath, commandsYaml, 'utf8');

  // Create a simple command registry for Claude CLI
  const registryScript = `#!/bin/bash
# Fluorite command registry
# This script registers all /fl: commands with Claude CLI

FLUORITE_DIR="${ClaudePaths.fluoriteDir}"
EXECUTOR="${executorPath}"

# Register each command
${commandDefs.map(cmd => `alias '${cmd.command}'='"$EXECUTOR" "${cmd.command}" "$@"'`).join('\n')}

echo "‚úÖ Fluorite commands registered with Claude CLI"
`;

  const registryPath = path.join(ClaudePaths.fluoriteDir, 'register-commands.sh');
  await fs.writeFile(registryPath, registryScript, 'utf8');
  
  // Make executable
  try {
    await execAsync(`chmod +x "${registryPath}"`);
  } catch (error) {
    console.warn('‚ö†Ô∏è  Could not set execute permissions on registry script');
  }
}

async function updateClaudeCommands(force: boolean): Promise<void> {
  const commandsPath = ClaudePaths.commandsFile;
  
  // Check if COMMANDS.md exists
  let commandsContent = '';
  try {
    commandsContent = await fs.readFile(commandsPath, 'utf8');
  } catch {
    // File doesn't exist, create base content
    commandsContent = `# Claude Code CLI Commands

This file contains command definitions for Claude Code CLI.

`;
  }

  // Check if fluorite commands are already added
  if (commandsContent.includes('## Fluorite Commands') && !force) {
    console.log('‚ÑπÔ∏è  Fluorite commands already exist in COMMANDS.md');
    return;
  }

  // Generate fluorite commands section with executable mappings
  const executorPath = path.join(ClaudePaths.fluoriteDir, 'executor.sh');
  const fluoriteSection = `
## Fluorite Commands

Enhanced SuperClaude commands with spike templates and optimizations.

**Command Executor**: \`${executorPath}\`

**Available Commands**:
${SuperClaudeCommands.getAll().map(cmd => `
**\`/fl:${cmd.name}\`**
- Purpose: ${cmd.description}
- Maps to: \`/sc:${cmd.name}\` with fluorite enhancements
- Usage: \`/fl:${cmd.name} ${cmd.usage || '[arguments]'}\`
- Features: Spike templates, token optimization, natural language
`).join('')}

**\`/fl:help\`**
- Purpose: Show help for fluorite commands
- Usage: \`/fl:help [command]\`

**\`/fl:spike\`**
- Purpose: Spike template operations
- Usage: 
  - \`/fl:spike discover [query]\`
  - \`/fl:spike apply [template]\`
  - \`/fl:spike list\`

**Command Processing**:
Fluorite commands are processed through \`${executorPath}\` which:
1. Parses the \`/fl:\` command syntax
2. Adds fluorite-specific enhancements (\`--persona-smart --token-optimize --spike-aware\`)
3. Maps to equivalent SuperClaude \`/sc:\` commands
4. Integrates with MCP server for spike templates

`;

  // Add fluorite section to commands
  if (commandsContent.includes('## Fluorite Commands')) {
    // Replace existing section
    const regex = /## Fluorite Commands[\s\S]*?(?=##|$)/;
    commandsContent = commandsContent.replace(regex, fluoriteSection.trim());
  } else {
    // Add new section
    commandsContent += fluoriteSection;
  }

  await fs.writeFile(commandsPath, commandsContent, 'utf8');
}

async function verifyInstallation(dryRun: boolean): Promise<void> {
  if (dryRun) {
    console.log('üìã Would verify fluorite-mcp installation');
    return;
  }

  // Check if configuration files exist
  try {
    await fs.access(ClaudePaths.fluoriteConfig);
    console.log('‚úÖ Fluorite configuration file created');
  } catch {
    throw new Error('Fluorite configuration file not found');
  }

  try {
    await fs.access(ClaudePaths.commandsFile);
    console.log('‚úÖ Claude commands file updated');
  } catch {
    console.log('‚ö†Ô∏è  Claude commands file not found (this is optional)');
  }

  // Check executor and registry files
  try {
    const executorPath = path.join(ClaudePaths.fluoriteDir, 'executor.sh');
    await fs.access(executorPath);
    console.log('‚úÖ Command executor created');
  } catch {
    throw new Error('Command executor not found');
  }

  try {
    const slashCommandsPath = path.join(ClaudePaths.fluoriteDir, 'slash-commands.yaml');
    await fs.access(slashCommandsPath);
    console.log('‚úÖ Slash command definitions created');
  } catch {
    throw new Error('Slash command definitions not found');
  }

  // Test MCP server connection
  try {
    await execAsync('claude mcp list');
    console.log('‚úÖ MCP server connection verified');
  } catch {
    console.log('‚ö†Ô∏è  Could not verify MCP server connection');
  }
}