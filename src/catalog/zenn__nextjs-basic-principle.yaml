id: "zenn/nextjs-basic-principle"
name: "Next.js の考え方（App Router 実践要点)"
homepage: "https://zenn.dev/akfm/books/nextjs-basic-principle"
summary: "App Router 時代の Next.js の設計原則と実装作法。RSC（サーバーコンポーネント）を中心に、データ取得・キャッシュ・ストリーミング・ルーティング・状態管理・境界の切り方を整理。"
principles:
  - "Server-first: 可能な限りサーバーコンポーネント（RSC）で実装し、クライアント側は UI/相互作用のみ"
  - "Colocation: データ取得・UI・スタイル・テストを機能単位で近接配置"
  - "Least client: クライアント境界（'use client'）は薄く、小さく保つ"
  - "Cache-aware: fetch のキャッシュ/再検証・タグ・パスを理解し、安定した UX を設計"
  - "Progressive rendering: loading.tsx/streaming で段階的表示"
  - "File routing as API: layout/page/route/middleware などの規約を活用し、複雑性をファイル構造で管理"
routing:
  structureExample: |
    app/
      layout.tsx            // ルートレイアウト
      page.tsx              // トップ
      dashboard/
        layout.tsx          // サブレイアウト
        page.tsx
        @slot/              // Parallel routes
        (marketing)/         // Route groups（URL に影響しない）
        settings/
          page.tsx
        users/
          [id]/page.tsx     // Dynamic route
          [id]/loading.tsx  // セグメント単位のローディング
        error.tsx           // エラー境界
        not-found.tsx       // 404 専用
  routeHandler: |
    // app/api/posts/route.ts（App Router の API）
    import { NextResponse } from 'next/server'
    export async function GET() { return NextResponse.json([{ id: 1 }]) }
    export async function POST(req: Request) { const body = await req.json(); /* ... */ return NextResponse.json({ ok: true }) }
dataFetching:
  serverComponent: |
    // サーバーコンポーネント（推奨デフォルト）
    async function getPosts() {
      const res = await fetch('https://example.com/api/posts', { cache: 'force-cache' })
      if (!res.ok) throw new Error('Failed')
      return res.json() as Promise<{ id: number; title: string }[]>
    }
    export default async function Page() {
      const posts = await getPosts() // サーバーで実行
      return (
        <ul>{posts.map(p => <li key={p.id}>{p.title}</li>)}</ul>
      )
    }
  revalidateAndTags: |
    // 時間指定の再検証
    export const revalidate = 60 // 秒

    // タグを使った無効化
    import { revalidateTag } from 'next/cache'
    async function getProduct(id: string) {
      const res = await fetch(`https://example.com/products/${id}`, { next: { tags: ['product', `product:${id}`] } })
      return res.json()
    }
    export async function POST() {
      // 変更後に関連ビューを再検証
      revalidateTag('product')
      return new Response('ok')
    }
  dynamicData: |
    // ユーザーごと等キャッシュ不可のデータ
    export const dynamic = 'force-dynamic'
    export default async function Page() { /* ... */ }
streaming:
  loadingAndSuspense: |
    // loading.tsx で骨組みを即時表示し、ページ内は Suspense で分割
    // app/dashboard/loading.tsx
    export default function Loading() { return <div>Loading dashboard...</div> }

    // app/dashboard/page.tsx
    import { Suspense } from 'react'
    import { SlowSection } from './_components/slow-section'
    export default function Dashboard() {
      return (
        <>
          <Summary />
          <Suspense fallback={<div>Loading details...</div>}>
            <SlowSection />
          </Suspense>
        </>
      )
    }
clientBoundary:
  minimalClient: |
    // 相互作用が必要な部分のみ 'use client'
    'use client'
    import { useState } from 'react'
    export function Counter({ initial = 0 }: { initial?: number }) {
      const [n, setN] = useState(initial)
      return <button onClick={() => setN(n + 1)}>{n}</button>
    }
  serverAction: |
    // フォーム + Server Actions（Beta の場合は設定に従う）
    // app/actions.ts
    'use server'
    export async function createPost(formData: FormData) { /* DB insert */ }

    // app/posts/page.tsx
    import { createPost } from '../actions'
    export default function Page() {
      return (
        <form action={createPost}>
          <input name="title" />
          <button>Save</button>
        </form>
      )
    }
stateAndStyling:
  guidance: |
    // 状態管理は "UI の相互作用" に限定してクライアントへ
    // グローバル/共有状態は可能ならサーバーで計算しプロップとして渡す
    // スタイリングは好みに応じて（CSS Modules, Tailwind, CSS-in-JS）を選択
middleware:
  example: |
    // middleware.ts（A/B、認可、ロケール付与など）
    import { NextResponse } from 'next/server'
    import type { NextRequest } from 'next/server'
    export function middleware(req: NextRequest) {
      // 例: /admin を認可チェック
      if (req.nextUrl.pathname.startsWith('/admin')) {
        const authorized = false // 実装
        if (!authorized) return NextResponse.redirect(new URL('/login', req.url))
      }
      return NextResponse.next()
    }
bestPractices:
  - "RSC でデータ取得・整形・結合を担い、クライアントは見た目と操作に集中"
  - "fetch のキャッシュ戦略（force-cache/revalidate/force-dynamic）を明示し、偶発的なキャッシュ不整合を避ける"
  - "エラー境界（error.tsx）と not-found.tsx を用意し、失敗時の UX を設計"
  - "Parallel/Intercepting routes は情報構造に沿って必要最小限に運用"
  - "環境に応じた実行ランタイム（Edge/Node）を把握し、非対応 API を避ける"
notes:
  - "本コンテキストは実装上の要点を抽出。詳細は原著の各章に従う"
references:
  - "Zenn: https://zenn.dev/akfm/books/nextjs-basic-principle"
  - "Next.js App Router: https://nextjs.org/docs/app"
license: "CC-BY-NC-SA?（原著に準拠・参照要）"
lastReviewed: "2025-08-14"

