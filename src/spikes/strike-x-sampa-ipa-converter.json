{
  "id": "strike-x-sampa-ipa-converter",
  "name": "X-SAMPA to IPA Converter",
  "stack": [
    "typescript",
    "linguistics",
    "phonetics"
  ],
  "tags": [
    "x-sampa",
    "ipa",
    "phonetics",
    "linguistics",
    "unicode",
    "converter"
  ],
  "description": "Bidirectional converter between X-SAMPA (ASCII) and IPA (Unicode) phonetic notations with validation and feature extraction",
  "files": [
    {
      "path": "src/phonetics/xsampa-converter.ts",
      "template": "/**\n * X-SAMPA to IPA bidirectional converter\n * Supports ASCII-based phonetic notation conversion\n */\n\nexport interface PhoneticFeatures {\n  voicing: 'voiced' | 'voiceless';\n  place: string;\n  manner: string;\n  type: 'consonant' | 'vowel' | 'suprasegmental';\n}\n\nexport interface PhonemeInfo {\n  ipa: string;\n  xsampa: string;\n  features: PhoneticFeatures;\n  description: string;\n}\n\nexport class XSampaConverter {\n  private readonly xsampaToIpaMap = new Map<string, PhonemeInfo>([\n    // Consonants\n    ['p', { ipa: 'p', xsampa: 'p', features: { voicing: 'voiceless', place: 'bilabial', manner: 'plosive', type: 'consonant' }, description: 'voiceless bilabial plosive' }],\n    ['b', { ipa: 'b', xsampa: 'b', features: { voicing: 'voiced', place: 'bilabial', manner: 'plosive', type: 'consonant' }, description: 'voiced bilabial plosive' }],\n    ['t', { ipa: 't', xsampa: 't', features: { voicing: 'voiceless', place: 'alveolar', manner: 'plosive', type: 'consonant' }, description: 'voiceless alveolar plosive' }],\n    ['d', { ipa: 'd', xsampa: 'd', features: { voicing: 'voiced', place: 'alveolar', manner: 'plosive', type: 'consonant' }, description: 'voiced alveolar plosive' }],\n    ['k', { ipa: 'k', xsampa: 'k', features: { voicing: 'voiceless', place: 'velar', manner: 'plosive', type: 'consonant' }, description: 'voiceless velar plosive' }],\n    ['g', { ipa: 'g', xsampa: 'g', features: { voicing: 'voiced', place: 'velar', manner: 'plosive', type: 'consonant' }, description: 'voiced velar plosive' }],\n    ['f', { ipa: 'f', xsampa: 'f', features: { voicing: 'voiceless', place: 'labiodental', manner: 'fricative', type: 'consonant' }, description: 'voiceless labiodental fricative' }],\n    ['v', { ipa: 'v', xsampa: 'v', features: { voicing: 'voiced', place: 'labiodental', manner: 'fricative', type: 'consonant' }, description: 'voiced labiodental fricative' }],\n    ['T', { ipa: 'θ', xsampa: 'T', features: { voicing: 'voiceless', place: 'dental', manner: 'fricative', type: 'consonant' }, description: 'voiceless dental fricative' }],\n    ['D', { ipa: 'ð', xsampa: 'D', features: { voicing: 'voiced', place: 'dental', manner: 'fricative', type: 'consonant' }, description: 'voiced dental fricative' }],\n    ['s', { ipa: 's', xsampa: 's', features: { voicing: 'voiceless', place: 'alveolar', manner: 'fricative', type: 'consonant' }, description: 'voiceless alveolar fricative' }],\n    ['z', { ipa: 'z', xsampa: 'z', features: { voicing: 'voiced', place: 'alveolar', manner: 'fricative', type: 'consonant' }, description: 'voiced alveolar fricative' }],\n    ['S', { ipa: 'ʃ', xsampa: 'S', features: { voicing: 'voiceless', place: 'postalveolar', manner: 'fricative', type: 'consonant' }, description: 'voiceless postalveolar fricative' }],\n    ['Z', { ipa: 'ʒ', xsampa: 'Z', features: { voicing: 'voiced', place: 'postalveolar', manner: 'fricative', type: 'consonant' }, description: 'voiced postalveolar fricative' }],\n    ['h', { ipa: 'h', xsampa: 'h', features: { voicing: 'voiceless', place: 'glottal', manner: 'fricative', type: 'consonant' }, description: 'voiceless glottal fricative' }],\n    ['m', { ipa: 'm', xsampa: 'm', features: { voicing: 'voiced', place: 'bilabial', manner: 'nasal', type: 'consonant' }, description: 'voiced bilabial nasal' }],\n    ['n', { ipa: 'n', xsampa: 'n', features: { voicing: 'voiced', place: 'alveolar', manner: 'nasal', type: 'consonant' }, description: 'voiced alveolar nasal' }],\n    ['N', { ipa: 'ŋ', xsampa: 'N', features: { voicing: 'voiced', place: 'velar', manner: 'nasal', type: 'consonant' }, description: 'voiced velar nasal' }],\n    ['l', { ipa: 'l', xsampa: 'l', features: { voicing: 'voiced', place: 'alveolar', manner: 'lateral', type: 'consonant' }, description: 'voiced alveolar lateral' }],\n    ['r', { ipa: 'r', xsampa: 'r', features: { voicing: 'voiced', place: 'alveolar', manner: 'trill', type: 'consonant' }, description: 'voiced alveolar trill' }],\n    ['j', { ipa: 'j', xsampa: 'j', features: { voicing: 'voiced', place: 'palatal', manner: 'approximant', type: 'consonant' }, description: 'voiced palatal approximant' }],\n    ['w', { ipa: 'w', xsampa: 'w', features: { voicing: 'voiced', place: 'labio-velar', manner: 'approximant', type: 'consonant' }, description: 'voiced labio-velar approximant' }],\n    \n    // Vowels\n    ['i', { ipa: 'i', xsampa: 'i', features: { voicing: 'voiced', place: 'front', manner: 'close', type: 'vowel' }, description: 'close front unrounded vowel' }],\n    ['I', { ipa: 'ɪ', xsampa: 'I', features: { voicing: 'voiced', place: 'front', manner: 'near-close', type: 'vowel' }, description: 'near-close front unrounded vowel' }],\n    ['e', { ipa: 'e', xsampa: 'e', features: { voicing: 'voiced', place: 'front', manner: 'close-mid', type: 'vowel' }, description: 'close-mid front unrounded vowel' }],\n    ['E', { ipa: 'ɛ', xsampa: 'E', features: { voicing: 'voiced', place: 'front', manner: 'open-mid', type: 'vowel' }, description: 'open-mid front unrounded vowel' }],\n    ['{', { ipa: 'æ', xsampa: '{', features: { voicing: 'voiced', place: 'front', manner: 'near-open', type: 'vowel' }, description: 'near-open front unrounded vowel' }],\n    ['a', { ipa: 'a', xsampa: 'a', features: { voicing: 'voiced', place: 'front', manner: 'open', type: 'vowel' }, description: 'open front unrounded vowel' }],\n    ['@', { ipa: 'ə', xsampa: '@', features: { voicing: 'voiced', place: 'central', manner: 'mid', type: 'vowel' }, description: 'mid central vowel (schwa)' }],\n    ['3', { ipa: 'ɜ', xsampa: '3', features: { voicing: 'voiced', place: 'central', manner: 'open-mid', type: 'vowel' }, description: 'open-mid central unrounded vowel' }],\n    ['A', { ipa: 'ɑ', xsampa: 'A', features: { voicing: 'voiced', place: 'back', manner: 'open', type: 'vowel' }, description: 'open back unrounded vowel' }],\n    ['O', { ipa: 'ɔ', xsampa: 'O', features: { voicing: 'voiced', place: 'back', manner: 'open-mid', type: 'vowel' }, description: 'open-mid back rounded vowel' }],\n    ['o', { ipa: 'o', xsampa: 'o', features: { voicing: 'voiced', place: 'back', manner: 'close-mid', type: 'vowel' }, description: 'close-mid back rounded vowel' }],\n    ['U', { ipa: 'ʊ', xsampa: 'U', features: { voicing: 'voiced', place: 'back', manner: 'near-close', type: 'vowel' }, description: 'near-close back rounded vowel' }],\n    ['u', { ipa: 'u', xsampa: 'u', features: { voicing: 'voiced', place: 'back', manner: 'close', type: 'vowel' }, description: 'close back rounded vowel' }],\n    \n    // Suprasegmentals\n    [\"'\", { ipa: 'ˈ', xsampa: \"'\", features: { voicing: 'voiceless', place: 'suprasegmental', manner: 'stress', type: 'suprasegmental' }, description: 'primary stress' }],\n    ['%', { ipa: 'ˌ', xsampa: '%', features: { voicing: 'voiceless', place: 'suprasegmental', manner: 'stress', type: 'suprasegmental' }, description: 'secondary stress' }],\n    [':', { ipa: 'ː', xsampa: ':', features: { voicing: 'voiceless', place: 'suprasegmental', manner: 'length', type: 'suprasegmental' }, description: 'long vowel' }]\n  ]);\n\n  private readonly ipaToXsampaMap = new Map<string, PhonemeInfo>();\n\n  constructor() {\n    // Build reverse mapping\n    for (const [xsampa, info] of this.xsampaToIpaMap) {\n      this.ipaToXsampaMap.set(info.ipa, info);\n    }\n  }\n\n  /**\n   * Convert X-SAMPA notation to IPA\n   */\n  xsampaToIpa(xsampa: string): string {\n    let result = '';\n    let i = 0;\n    \n    while (i < xsampa.length) {\n      // Try longest match first (for multi-character X-SAMPA symbols)\n      let found = false;\n      for (let len = Math.min(3, xsampa.length - i); len > 0; len--) {\n        const segment = xsampa.substr(i, len);\n        const phonemeInfo = this.xsampaToIpaMap.get(segment);\n        if (phonemeInfo) {\n          result += phonemeInfo.ipa;\n          i += len;\n          found = true;\n          break;\n        }\n      }\n      \n      if (!found) {\n        result += xsampa[i];\n        i++;\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Convert IPA notation to X-SAMPA\n   */\n  ipaToXsampa(ipa: string): string {\n    let result = '';\n    \n    for (const char of ipa) {\n      const phonemeInfo = this.ipaToXsampaMap.get(char);\n      if (phonemeInfo) {\n        result += phonemeInfo.xsampa;\n      } else {\n        result += char;\n      }\n    }\n    \n    return result;\n  }\n\n  /**\n   * Get phonetic features for a phoneme\n   */\n  getPhonemeFeatures(phoneme: string, format: 'ipa' | 'xsampa' = 'ipa'): PhoneticFeatures | null {\n    const map = format === 'ipa' ? this.ipaToXsampaMap : this.xsampaToIpaMap;\n    const info = map.get(phoneme);\n    return info ? info.features : null;\n  }\n\n  /**\n   * Validate phonetic notation\n   */\n  validateNotation(notation: string, format: 'ipa' | 'xsampa'): boolean {\n    const map = format === 'ipa' ? this.ipaToXsampaMap : this.xsampaToIpaMap;\n    return [...notation].every(char => map.has(char) || /\\s/.test(char));\n  }\n\n  /**\n   * Get all available phonemes\n   */\n  getPhonemeInventory(format: 'ipa' | 'xsampa' = 'ipa'): PhonemeInfo[] {\n    const map = format === 'ipa' ? this.ipaToXsampaMap : this.xsampaToIpaMap;\n    return Array.from(map.values());\n  }\n\n  /**\n   * Filter phonemes by type\n   */\n  getPhonemesByType(type: 'consonant' | 'vowel' | 'suprasegmental'): PhonemeInfo[] {\n    return Array.from(this.xsampaToIpaMap.values())\n      .filter(info => info.features.type === type);\n  }\n}\n\n// Export singleton instance\nexport const xsampaConverter = new XSampaConverter();\n"
    },
    {
      "path": "src/phonetics/phonetic-utils.ts",
      "template": "/**\n * Utility functions for phonetic processing\n */\n\nimport { xsampaConverter, PhonemeInfo } from './xsampa-converter';\n\nexport interface SyllableStructure {\n  onset: string[];\n  nucleus: string[];\n  coda: string[];\n}\n\nexport interface PhoneticAnalysis {\n  transcription: string;\n  syllables: SyllableStructure[];\n  stress: number[];\n  length: number;\n  consonants: PhonemeInfo[];\n  vowels: PhonemeInfo[];\n}\n\n/**\n * Analyze phonetic transcription\n */\nexport function analyzePhonetics(ipa: string): PhoneticAnalysis {\n  const phonemes = xsampaConverter.getPhonemeInventory('ipa');\n  const consonants: PhonemeInfo[] = [];\n  const vowels: PhonemeInfo[] = [];\n  const stress: number[] = [];\n  \n  for (const char of ipa) {\n    const phoneme = phonemes.find(p => p.ipa === char);\n    if (phoneme) {\n      if (phoneme.features.type === 'consonant') {\n        consonants.push(phoneme);\n      } else if (phoneme.features.type === 'vowel') {\n        vowels.push(phoneme);\n      }\n    }\n    \n    // Detect stress markers\n    if (char === 'ˈ') stress.push(1); // primary\n    if (char === 'ˌ') stress.push(2); // secondary\n  }\n  \n  return {\n    transcription: ipa,\n    syllables: [], // TODO: implement syllabification\n    stress,\n    length: ipa.length,\n    consonants,\n    vowels\n  };\n}\n\n/**\n * Convert between different phonetic notations\n */\nexport function convertPhonetics(input: string, from: 'ipa' | 'xsampa', to: 'ipa' | 'xsampa'): string {\n  if (from === to) return input;\n  \n  if (from === 'xsampa' && to === 'ipa') {\n    return xsampaConverter.xsampaToIpa(input);\n  } else if (from === 'ipa' && to === 'xsampa') {\n    return xsampaConverter.ipaToXsampa(input);\n  }\n  \n  throw new Error(`Unsupported conversion: ${from} to ${to}`);\n}\n\n/**\n * Generate phonetic variants for a given transcription\n */\nexport function generatePhoneticVariants(ipa: string): string[] {\n  const variants: string[] = [ipa];\n  \n  // Add stress variants\n  const withPrimaryStress = 'ˈ' + ipa;\n  const withSecondaryStress = 'ˌ' + ipa;\n  variants.push(withPrimaryStress, withSecondaryStress);\n  \n  // Add length variants for vowels\n  const withLength = ipa.replace(/[aeiouɪɛæəɜɑɔʊ]/g, '$&ː');\n  variants.push(withLength);\n  \n  return [...new Set(variants)];\n}\n\n/**\n * Calculate phonetic similarity between two transcriptions\n */\nexport function calculatePhoneticSimilarity(ipa1: string, ipa2: string): number {\n  const features1 = analyzePhonetics(ipa1);\n  const features2 = analyzePhonetics(ipa2);\n  \n  // Simple similarity based on shared phonemes\n  const phonemes1 = new Set([...features1.consonants, ...features1.vowels].map(p => p.ipa));\n  const phonemes2 = new Set([...features2.consonants, ...features2.vowels].map(p => p.ipa));\n  \n  const intersection = new Set([...phonemes1].filter(p => phonemes2.has(p)));\n  const union = new Set([...phonemes1, ...phonemes2]);\n  \n  return intersection.size / union.size;\n}\n"
    },
    {
      "path": "test/phonetics.test.ts",
      "template": "/**\n * Test suite for phonetic processing\n */\n\nimport { describe, it, expect } from 'vitest';\nimport { xsampaConverter } from '../src/phonetics/xsampa-converter';\nimport { analyzePhonetics, convertPhonetics, calculatePhoneticSimilarity } from '../src/phonetics/phonetic-utils';\n\ndescribe('X-SAMPA Converter', () => {\n  it('should convert X-SAMPA to IPA', () => {\n    expect(xsampaConverter.xsampaToIpa('hE\"loU')).toBe('hɛˈloʊ');\n    expect(xsampaConverter.xsampaToIpa('S')).toBe('ʃ');\n    expect(xsampaConverter.xsampaToIpa('T')).toBe('θ');\n    expect(xsampaConverter.xsampaToIpa('D')).toBe('ð');\n    expect(xsampaConverter.xsampaToIpa('N')).toBe('ŋ');\n  });\n\n  it('should convert IPA to X-SAMPA', () => {\n    expect(xsampaConverter.ipaToXsampa('ʃ')).toBe('S');\n    expect(xsampaConverter.ipaToXsampa('θ')).toBe('T');\n    expect(xsampaConverter.ipaToXsampa('ð')).toBe('D');\n    expect(xsampaConverter.ipaToXsampa('ŋ')).toBe('N');\n    expect(xsampaConverter.ipaToXsampa('ə')).toBe('@');\n  });\n\n  it('should validate phonetic notation', () => {\n    expect(xsampaConverter.validateNotation('hɛˈloʊ', 'ipa')).toBe(true);\n    expect(xsampaConverter.validateNotation('hE\"loU', 'xsampa')).toBe(true);\n    expect(xsampaConverter.validateNotation('xyz', 'ipa')).toBe(false);\n  });\n\n  it('should get phoneme features', () => {\n    const features = xsampaConverter.getPhonemeFeatures('ʃ', 'ipa');\n    expect(features).toEqual({\n      voicing: 'voiceless',\n      place: 'postalveolar',\n      manner: 'fricative',\n      type: 'consonant'\n    });\n  });\n\n  it('should filter phonemes by type', () => {\n    const vowels = xsampaConverter.getPhonemesByType('vowel');\n    expect(vowels.length).toBeGreaterThan(0);\n    expect(vowels.every(p => p.features.type === 'vowel')).toBe(true);\n  });\n});\n\ndescribe('Phonetic Utils', () => {\n  it('should analyze phonetic transcription', () => {\n    const analysis = analyzePhonetics('hɛˈloʊ');\n    expect(analysis.consonants.length).toBeGreaterThan(0);\n    expect(analysis.vowels.length).toBeGreaterThan(0);\n    expect(analysis.stress).toContain(1);\n  });\n\n  it('should convert between notations', () => {\n    expect(convertPhonetics('S', 'xsampa', 'ipa')).toBe('ʃ');\n    expect(convertPhonetics('ʃ', 'ipa', 'xsampa')).toBe('S');\n    expect(convertPhonetics('hello', 'ipa', 'ipa')).toBe('hello');\n  });\n\n  it('should calculate phonetic similarity', () => {\n    const similarity = calculatePhoneticSimilarity('hɛloʊ', 'hɛloʊ');\n    expect(similarity).toBe(1);\n    \n    const partialSimilarity = calculatePhoneticSimilarity('hɛloʊ', 'hɪloʊ');\n    expect(partialSimilarity).toBeGreaterThan(0.5);\n  });\n});\n"
    },
    {
      "path": "package.json",
      "template": "{\n  \"name\": \"phonetic-processor\",\n  \"version\": \"1.0.0\",\n  \"description\": \"X-SAMPA to IPA converter with phonetic analysis\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"test\": \"vitest\",\n    \"dev\": \"tsc --watch\",\n    \"lint\": \"eslint src/**/*.ts\"\n  },\n  \"dependencies\": {\n    \"unicode-normalize\": \"^1.0.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"typescript\": \"^5.0.0\",\n    \"vitest\": \"^1.0.0\",\n    \"eslint\": \"^8.0.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.0.0\",\n    \"@typescript-eslint/parser\": \"^6.0.0\"\n  },\n  \"keywords\": [\n    \"phonetics\",\n    \"x-sampa\",\n    \"ipa\",\n    \"linguistics\",\n    \"speech\",\n    \"unicode\"\n  ]\n}\n"
    },
    {
      "path": "tsconfig.json",
      "template": "{\n  \"compilerOptions\": {\n    \"target\": \"ES2022\",\n    \"module\": \"ESNext\",\n    \"moduleResolution\": \"node\",\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"esModuleInterop\": true,\n    \"skipLibCheck\": true,\n    \"forceConsistentCasingInFileNames\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true,\n    \"removeComments\": false,\n    \"noImplicitAny\": true,\n    \"noImplicitReturns\": true,\n    \"noImplicitThis\": true,\n    \"strictNullChecks\": true,\n    \"strictPropertyInitialization\": true,\n    \"lib\": [\"ES2022\", \"DOM\"]\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"test\"]\n}\n"
    },
    {
      "path": "README.md",
      "template": "# Phonetic Processor\n\nA comprehensive TypeScript library for phonetic notation processing, featuring bidirectional conversion between X-SAMPA (ASCII) and IPA (Unicode) notations.\n\n## Features\n\n- **Bidirectional Conversion**: Convert between X-SAMPA and IPA notations\n- **Feature Analysis**: Extract phonetic features (voicing, place, manner)\n- **Validation**: Validate phonetic transcriptions\n- **Similarity Calculation**: Compare phonetic transcriptions\n- **Type Safety**: Full TypeScript support with detailed type definitions\n\n## Installation\n\n```bash\nnpm install phonetic-processor\n```\n\n## Usage\n\n### Basic Conversion\n\n```typescript\nimport { xsampaConverter } from 'phonetic-processor';\n\n// X-SAMPA to IPA\nconst ipa = xsampaConverter.xsampaToIpa('hE\"loU'); // → 'hɛˈloʊ'\nconst fricative = xsampaConverter.xsampaToIpa('S'); // → 'ʃ'\n\n// IPA to X-SAMPA\nconst xsampa = xsampaConverter.ipaToXsampa('ʃ'); // → 'S'\nconst schwa = xsampaConverter.ipaToXsampa('ə'); // → '@'\n```\n\n### Phonetic Analysis\n\n```typescript\nimport { analyzePhonetics, calculatePhoneticSimilarity } from 'phonetic-processor';\n\n// Analyze phonetic transcription\nconst analysis = analyzePhonetics('hɛˈloʊ');\nconsole.log(analysis.consonants); // Consonant phonemes\nconsole.log(analysis.vowels);     // Vowel phonemes\nconsole.log(analysis.stress);     // Stress positions\n\n// Calculate similarity\nconst similarity = calculatePhoneticSimilarity('hɛloʊ', 'hɪloʊ'); // 0.8\n```\n\n### Feature Extraction\n\n```typescript\nconst features = xsampaConverter.getPhonemeFeatures('ʃ', 'ipa');\nconsole.log(features);\n// {\n//   voicing: 'voiceless',\n//   place: 'postalveolar',\n//   manner: 'fricative',\n//   type: 'consonant'\n// }\n```\n\n### Validation\n\n```typescript\n// Validate phonetic notation\nconst isValidIPA = xsampaConverter.validateNotation('hɛˈloʊ', 'ipa'); // true\nconst isValidXSAMPA = xsampaConverter.validateNotation('hE\"loU', 'xsampa'); // true\n```\n\n## X-SAMPA Reference\n\n| IPA | X-SAMPA | Description |\n|-----|---------|-------------|\n| ʃ   | S       | voiceless postalveolar fricative |\n| ʒ   | Z       | voiced postalveolar fricative |\n| θ   | T       | voiceless dental fricative |\n| ð   | D       | voiced dental fricative |\n| ŋ   | N       | voiced velar nasal |\n| ə   | @       | schwa |\n| ɛ   | E       | open-mid front unrounded vowel |\n| ɪ   | I       | near-close front unrounded vowel |\n| ʊ   | U       | near-close back rounded vowel |\n| ɔ   | O       | open-mid back rounded vowel |\n| ˈ   | \"       | primary stress |\n| ˌ   | %       | secondary stress |\n| ː   | :       | length mark |\n\n## API Reference\n\n### XSampaConverter\n\n- `xsampaToIpa(xsampa: string): string` - Convert X-SAMPA to IPA\n- `ipaToXsampa(ipa: string): string` - Convert IPA to X-SAMPA\n- `getPhonemeFeatures(phoneme: string, format: 'ipa' | 'xsampa'): PhoneticFeatures | null`\n- `validateNotation(notation: string, format: 'ipa' | 'xsampa'): boolean`\n- `getPhonemeInventory(format: 'ipa' | 'xsampa'): PhonemeInfo[]`\n- `getPhonemesByType(type: 'consonant' | 'vowel' | 'suprasegmental'): PhonemeInfo[]`\n\n### Utility Functions\n\n- `analyzePhonetics(ipa: string): PhoneticAnalysis`\n- `convertPhonetics(input: string, from: 'ipa' | 'xsampa', to: 'ipa' | 'xsampa'): string`\n- `calculatePhoneticSimilarity(ipa1: string, ipa2: string): number`\n- `generatePhoneticVariants(ipa: string): string[]`\n\n## Contributing\n\nContributions are welcome! Please ensure all tests pass and follow the existing code style.\n\n```bash\nnpm test\nnpm run lint\n```\n\n## License\n\nMIT License - see LICENSE file for details.\n"
    }
  ],\n  \"patches\": []\n}"
    }
  ],
  "patches": []
}