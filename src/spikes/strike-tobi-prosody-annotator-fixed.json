{
  "id": "strike-tobi-prosody-annotator",
  "name": "ToBI Prosodic Annotation System",
  "stack": [
    "typescript",
    "linguistics",
    "prosody",
    "audio"
  ],
  "tags": [
    "tobi",
    "prosody",
    "intonation",
    "linguistics",
    "speech",
    "annotation",
    "rhythm"
  ],
  "description": "ToBI (Tones and Break Indices) prosodic annotation system for intonation pattern analysis and rhythm annotation",
  "files": [
    {
      "path": "src/prosody/tobi-annotator.ts",
      "template": "/**\n * ToBI (Tones and Break Indices) Prosodic Annotation System\n * Implements prosodic annotation for intonation and rhythm analysis\n */\n\nexport interface ToBITone {\n  type: 'H*' | 'L*' | 'H+L*' | 'L+H*' | 'H*+L' | 'L*+H' | 'H-' | 'L-' | 'H%' | 'L%' | '!H*' | '!L*';\n  position: number;\n  strength: number;\n  description: string;\n}\n\nexport interface BreakIndex {\n  level: 0 | 1 | 2 | 3 | 4;\n  position: number;\n  type: 'word' | 'phrase' | 'clause' | 'utterance';\n  description: string;\n}\n\nexport interface ProsodyFeatures {\n  pitch: number[];\n  intensity: number[];\n  duration: number[];\n  timestamps: number[];\n}\n\nexport interface ToBIAnnotation {\n  tones: ToBITone[];\n  breaks: BreakIndex[];\n  words: string[];\n  syllables: string[];\n  phonemes: string[];\n  features: ProsodyFeatures;\n  metadata: {\n    speaker?: string;\n    language: string;\n    dialect?: string;\n    speaking_rate: 'slow' | 'normal' | 'fast';\n    emotion?: string;\n    confidence: number;\n  };\n}\n\nexport class ToBIAnnotator {\n  private readonly toneDescriptions = new Map<string, string>([\n    ['H*', 'high pitch accent'],\n    ['L*', 'low pitch accent'],\n    ['H+L*', 'falling pitch accent (high leading tone)'],\n    ['L+H*', 'rising pitch accent (low leading tone)'],\n    ['H*+L', 'high pitch accent with low trailing tone'],\n    ['L*+H', 'low pitch accent with high trailing tone'],\n    ['H-', 'high phrase accent'],\n    ['L-', 'low phrase accent'],\n    ['H%', 'high boundary tone'],\n    ['L%', 'low boundary tone'],\n    ['!H*', 'downstepped high pitch accent'],\n    ['!L*', 'upstepped low pitch accent']\n  ]);\n\n  annotate(text: string, features: ProsodyFeatures, options?: {\n    language?: string;\n    dialect?: string;\n    auto_detect_breaks?: boolean;\n    auto_detect_tones?: boolean;\n  }): ToBIAnnotation {\n    const words = this.tokenizeWords(text);\n    const syllables = this.syllabify(words);\n    const phonemes = this.phonemize(syllables);\n    \n    const tones = options?.auto_detect_tones ? \n      this.detectTones(features.pitch, features.timestamps) : [];\n    \n    const breaks = options?.auto_detect_breaks ? \n      this.detectBreaks(words, features.intensity, features.timestamps) : [];\n\n    return {\n      tones,\n      breaks,\n      words,\n      syllables,\n      phonemes,\n      features,\n      metadata: {\n        language: options?.language || 'en-US',\n        dialect: options?.dialect,\n        speaking_rate: this.detectSpeakingRate(features.duration),\n        confidence: this.calculateConfidence(tones, breaks)\n      }\n    };\n  }\n\n  generateToBIString(annotation: ToBIAnnotation): string {\n    const lines: string[] = [];\n    \n    lines.push('words\\t' + annotation.words.join(' '));\n    \n    const breakString = annotation.breaks\n      .map(b => `${b.level}@${b.position}`)\n      .join(' ');\n    lines.push('break\\t' + breakString);\n    \n    const toneString = annotation.tones\n      .map(t => `${t.type}@${t.position}`)\n      .join(' ');\n    lines.push('tones\\t' + toneString);\n    \n    lines.push(`meta\\tlang=${annotation.metadata.language} rate=${annotation.metadata.speaking_rate} conf=${annotation.metadata.confidence.toFixed(2)}`);\n    \n    return lines.join('\\n');\n  }\n\n  private detectTones(pitch: number[], timestamps: number[]): ToBITone[] {\n    const tones: ToBITone[] = [];\n    const smoothedPitch = this.smoothPitch(pitch);\n    const peaks = this.findPeaks(smoothedPitch);\n    const valleys = this.findValleys(smoothedPitch);\n    \n    for (const peak of peaks) {\n      const position = timestamps[peak] || peak * 10;\n      const strength = this.calculateToneStrength(smoothedPitch, peak);\n      \n      tones.push({\n        type: 'H*',\n        position,\n        strength,\n        description: this.toneDescriptions.get('H*') || ''\n      });\n    }\n    \n    for (const valley of valleys) {\n      const position = timestamps[valley] || valley * 10;\n      const strength = this.calculateToneStrength(smoothedPitch, valley);\n      \n      tones.push({\n        type: 'L*',\n        position,\n        strength,\n        description: this.toneDescriptions.get('L*') || ''\n      });\n    }\n    \n    if (pitch.length > 0) {\n      const finalPitch = pitch[pitch.length - 1];\n      const meanPitch = pitch.reduce((a, b) => a + b) / pitch.length;\n      \n      tones.push({\n        type: finalPitch > meanPitch ? 'H%' : 'L%',\n        position: timestamps[timestamps.length - 1] || (pitch.length - 1) * 10,\n        strength: Math.abs(finalPitch - meanPitch) / meanPitch,\n        description: this.toneDescriptions.get(finalPitch > meanPitch ? 'H%' : 'L%') || ''\n      });\n    }\n    \n    return tones.sort((a, b) => a.position - b.position);\n  }\n\n  private detectBreaks(words: string[], intensity: number[], timestamps: number[]): BreakIndex[] {\n    const breaks: BreakIndex[] = [];\n    const wordBoundaries = this.findWordBoundaries(words, timestamps);\n    \n    for (let i = 0; i < wordBoundaries.length - 1; i++) {\n      const boundary = wordBoundaries[i];\n      const nextBoundary = wordBoundaries[i + 1];\n      \n      const pauseDuration = nextBoundary - boundary;\n      const intensityDrop = this.calculateIntensityDrop(intensity, boundary, nextBoundary);\n      \n      let level: 0 | 1 | 2 | 3 | 4;\n      let type: 'word' | 'phrase' | 'clause' | 'utterance';\n      \n      if (pauseDuration > 500 && intensityDrop > 0.7) {\n        level = 4;\n        type = 'utterance';\n      } else if (pauseDuration > 300 && intensityDrop > 0.5) {\n        level = 3;\n        type = 'phrase';\n      } else if (pauseDuration > 150 && intensityDrop > 0.3) {\n        level = 2;\n        type = 'word';\n      } else if (pauseDuration > 50) {\n        level = 1;\n        type = 'word';\n      } else {\n        level = 0;\n        type = 'word';\n      }\n      \n      breaks.push({\n        level,\n        position: boundary,\n        type,\n        description: `break level ${level}`\n      });\n    }\n    \n    return breaks;\n  }\n\n  private tokenizeWords(text: string): string[] {\n    return text.toLowerCase().replace(/[^\\w\\s]/g, '').split(/\\s+/).filter(w => w.length > 0);\n  }\n\n  private syllabify(words: string[]): string[] {\n    return words.flatMap(word => {\n      const syllables = word.match(/[bcdfghjklmnpqrstvwxyz]*[aeiou][bcdfghjklmnpqrstvwxyz]*/gi) || [word];\n      return syllables;\n    });\n  }\n\n  private phonemize(syllables: string[]): string[] {\n    return syllables.map(syl => {\n      return syl.replace(/th/g, 'θ')\n                .replace(/sh/g, 'ʃ')\n                .replace(/ch/g, 'tʃ')\n                .replace(/ng/g, 'ŋ');\n    });\n  }\n\n  private smoothPitch(pitch: number[]): number[] {\n    const windowSize = 5;\n    const smoothed: number[] = [];\n    \n    for (let i = 0; i < pitch.length; i++) {\n      const start = Math.max(0, i - Math.floor(windowSize / 2));\n      const end = Math.min(pitch.length, i + Math.ceil(windowSize / 2));\n      const window = pitch.slice(start, end);\n      const average = window.reduce((a, b) => a + b) / window.length;\n      smoothed.push(average);\n    }\n    \n    return smoothed;\n  }\n\n  private findPeaks(signal: number[]): number[] {\n    const peaks: number[] = [];\n    for (let i = 1; i < signal.length - 1; i++) {\n      if (signal[i] > signal[i - 1] && signal[i] > signal[i + 1]) {\n        peaks.push(i);\n      }\n    }\n    return peaks;\n  }\n\n  private findValleys(signal: number[]): number[] {\n    const valleys: number[] = [];\n    for (let i = 1; i < signal.length - 1; i++) {\n      if (signal[i] < signal[i - 1] && signal[i] < signal[i + 1]) {\n        valleys.push(i);\n      }\n    }\n    return valleys;\n  }\n\n  private calculateToneStrength(pitch: number[], position: number): number {\n    const localMean = this.calculateLocalMean(pitch, position, 10);\n    const globalMean = pitch.reduce((a, b) => a + b) / pitch.length;\n    return Math.abs(pitch[position] - localMean) / globalMean;\n  }\n\n  private calculateLocalMean(signal: number[], center: number, window: number): number {\n    const start = Math.max(0, center - window);\n    const end = Math.min(signal.length, center + window);\n    const slice = signal.slice(start, end);\n    return slice.reduce((a, b) => a + b) / slice.length;\n  }\n\n  private findWordBoundaries(words: string[], timestamps: number[]): number[] {\n    const boundaries: number[] = [];\n    const totalDuration = timestamps[timestamps.length - 1] - timestamps[0];\n    const avgWordDuration = totalDuration / words.length;\n    \n    for (let i = 0; i < words.length; i++) {\n      boundaries.push(timestamps[0] + i * avgWordDuration);\n    }\n    \n    return boundaries;\n  }\n\n  private calculateIntensityDrop(intensity: number[], start: number, end: number): number {\n    const startIdx = Math.floor(start / 10);\n    const endIdx = Math.floor(end / 10);\n    \n    if (startIdx >= intensity.length || endIdx >= intensity.length) return 0;\n    \n    const startIntensity = intensity[startIdx];\n    const endIntensity = intensity[endIdx];\n    \n    return Math.abs(startIntensity - endIntensity) / Math.max(startIntensity, endIntensity);\n  }\n\n  private detectSpeakingRate(durations: number[]): 'slow' | 'normal' | 'fast' {\n    const avgDuration = durations.reduce((a, b) => a + b) / durations.length;\n    \n    if (avgDuration > 150) return 'slow';\n    if (avgDuration < 80) return 'fast';\n    return 'normal';\n  }\n\n  private calculateConfidence(tones: ToBITone[], breaks: BreakIndex[]): number {\n    const toneConfidence = Math.min(1.0, tones.length / 10);\n    const breakConfidence = Math.min(1.0, breaks.length / 5);\n    return (toneConfidence + breakConfidence) / 2;\n  }\n}\n\nexport const tobiAnnotator = new ToBIAnnotator();\n"
    },
    {
      "path": "test/prosody.test.ts",
      "template": "import { describe, it, expect } from 'vitest';\nimport { tobiAnnotator, ToBIAnnotation } from '../src/prosody/tobi-annotator';\n\ndescribe('ToBI Annotator', () => {\n  it('should create basic ToBI annotation', () => {\n    const mockFeatures = {\n      pitch: [150, 180, 200, 170, 140],\n      intensity: [0.8, 0.9, 0.7, 0.6, 0.5],\n      duration: [100, 120, 110, 130, 140],\n      timestamps: [0, 100, 220, 330, 460]\n    };\n    \n    const annotation = tobiAnnotator.annotate('Hello world', mockFeatures, {\n      language: 'en-US',\n      auto_detect_tones: true,\n      auto_detect_breaks: true\n    });\n    \n    expect(annotation.words).toEqual(['hello', 'world']);\n    expect(annotation.tones.length).toBeGreaterThan(0);\n    expect(annotation.breaks.length).toBeGreaterThan(0);\n    expect(annotation.metadata.language).toBe('en-US');\n  });\n\n  it('should generate ToBI string representation', () => {\n    const mockAnnotation: ToBIAnnotation = {\n      words: ['hello', 'world'],\n      tones: [{\n        type: 'H*',\n        position: 100,\n        strength: 0.8,\n        description: 'high pitch accent'\n      }],\n      breaks: [{\n        level: 1,\n        position: 250,\n        type: 'word',\n        description: 'weak word boundary'\n      }],\n      syllables: ['hel', 'lo', 'world'],\n      phonemes: ['h', 'ɛ', 'l', 'o', 'w', 'ə', 'r', 'l', 'd'],\n      features: {\n        pitch: [150, 180, 140],\n        intensity: [0.8, 0.9, 0.7],\n        duration: [100, 120, 110],\n        timestamps: [0, 100, 220]\n      },\n      metadata: {\n        language: 'en-US',\n        speaking_rate: 'normal',\n        confidence: 0.8\n      }\n    };\n    \n    const tobiString = tobiAnnotator.generateToBIString(mockAnnotation);\n    expect(tobiString).toContain('words\\thello world');\n    expect(tobiString).toContain('H*@100');\n    expect(tobiString).toContain('1@250');\n  });\n});\n"
    },
    {
      "path": "package.json",
      "template": "{\n  \"name\": \"tobi-prosody-annotator\",\n  \"version\": \"1.0.0\",\n  \"description\": \"ToBI (Tones and Break Indices) prosodic annotation system\",\n  \"type\": \"module\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"test\": \"vitest\",\n    \"dev\": \"tsc --watch\",\n    \"lint\": \"eslint src/**/*.ts\"\n  },\n  \"dependencies\": {\n    \"audio-buffer\": \"^5.0.0\",\n    \"fft-js\": \"^0.0.12\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"typescript\": \"^5.0.0\",\n    \"vitest\": \"^1.0.0\",\n    \"eslint\": \"^8.0.0\",\n    \"@typescript-eslint/eslint-plugin\": \"^6.0.0\",\n    \"@typescript-eslint/parser\": \"^6.0.0\"\n  },\n  \"keywords\": [\n    \"tobi\",\n    \"prosody\",\n    \"intonation\",\n    \"linguistics\",\n    \"speech\",\n    \"annotation\",\n    \"rhythm\",\n    \"pitch\",\n    \"tones\",\n    \"breaks\"\n  ]\n}\n"
    },
    {
      "path": "README.md",
      "template": "# ToBI Prosodic Annotation System\\n\\nA TypeScript implementation of the ToBI (Tones and Break Indices) system for prosodic annotation.\\n\\n## Features\\n\\n- ToBI annotation with automatic tone and break detection\\n- Prosodic analysis of rhythm, intonation, and phrasing\\n- Speaking style detection\\n- TypeScript support\\n\\n## Installation\\n\\n```bash\\nnpm install tobi-prosody-annotator\\n```\\n\\n## Usage\\n\\n```typescript\\nimport { tobiAnnotator } from 'tobi-prosody-annotator';\\n\\nconst prosodyFeatures = {\\n  pitch: [150, 180, 200, 170, 140],\\n  intensity: [0.8, 0.9, 0.7, 0.6, 0.5],\\n  duration: [100, 120, 110, 130, 140],\\n  timestamps: [0, 100, 220, 330, 460]\\n};\\n\\nconst annotation = tobiAnnotator.annotate('Hello world', prosodyFeatures, {\\n  language: 'en-US',\\n  auto_detect_tones: true,\\n  auto_detect_breaks: true\\n});\\n\\nconsole.log(annotation.tones);\\nconsole.log(annotation.breaks);\\n```\\n\\n## ToBI Reference\\n\\n### Tone Types\\n\\n- H*: High pitch accent\\n- L*: Low pitch accent\\n- H%: High boundary tone\\n- L%: Low boundary tone\\n\\n### Break Indices\\n\\n- 0: Clitic boundary\\n- 1: Weak word boundary\\n- 2: Strong word boundary\\n- 3: Intermediate phrase boundary\\n- 4: Intonational phrase boundary\\n\\n## License\\n\\nMIT\\n"
    }
  ],
  "patches": []
}