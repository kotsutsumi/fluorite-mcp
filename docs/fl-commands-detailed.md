# /fl: Commands - Complete Reference

Enhanced fluorite-mcp commands with SuperClaude parameter bypass and Spike development workflow integration.

## Overview

The `/fl:` command series provides enhanced fluorite-mcp functionality with complete SuperClaude parameter bypass support. These commands bridge Claude Code CLI with fluorite-mcp's comprehensive library knowledge and Spike development workflows.

**Key Features**:
- üöÄ **SuperClaude Integration**: Full parameter bypass support (`--loop`, `--wave-mode`, `--delegate`, etc.)
- üìö **Library Knowledge**: Access to 87+ library specifications and patterns
- üõ†Ô∏è **Spike Templates**: 206 production-ready development scaffolds
- üéØ **Intelligent Automation**: AI-powered template selection and code generation
- üîÑ **Iterative Workflows**: Built-in refinement and quality validation

## Command Reference

### Core Development Commands

#### `/fl:implement`

Enhanced feature implementation with Spike development integration.

**Syntax**:
```bash
/fl:implement [--flags] "feature description"
```

**SuperClaude Parameters**:
- `--loop`: Iterative implementation with refinement
- `--wave-mode`: Multi-stage implementation strategy
- `--delegate`: Parallel task delegation
- `--until-perfect`: Quality validation loops
- `--ultrathink`: Deep architectural analysis
- `--all-mcp`: All MCP server integration

**Features**:
- Automatic library specification lookup
- Spike template integration
- Best practice enforcement
- Type safety validation
- Security pattern application

**Example**:
```bash
/fl:implement --loop --wave-mode "React drag-and-drop tree component with accessibility"
```

**Workflow**:
1. üîç **Analysis**: Understand requirements and existing codebase
2. üìö **Library Research**: Access relevant specifications from catalog
3. üèóÔ∏è **Spike Selection**: Choose optimal template(s) for implementation
4. ‚ö° **Code Generation**: Create implementation with best practices
5. ‚úÖ **Validation**: Type checking, security scanning, testing
6. üîÑ **Refinement**: Iterative improvements until quality standards met

#### `/fl:analyze`

Comprehensive code and project analysis with intelligent insights.

**Syntax**:
```bash
/fl:analyze [--flags] [path/pattern]
```

**Analysis Capabilities**:
- **Static Analysis**: Code quality, security vulnerabilities, performance issues
- **Dependency Analysis**: Package vulnerabilities, outdated dependencies
- **Architecture Review**: Design patterns, coupling analysis, modularity assessment
- **Performance Profiling**: Bundle size, rendering performance, memory usage
- **Security Scanning**: OWASP compliance, secret detection, access control

**Example**:
```bash
/fl:analyze --ultrathink --all-mcp "src/components/**/*.tsx"
```

#### `/fl:build`

Enhanced build operations with framework optimization.

**Syntax**:
```bash
/fl:build [--flags] [target]
```

**Build Features**:
- Framework-specific optimizations
- Bundle analysis and optimization
- Performance budgeting
- Security validation
- Type checking integration

#### `/fl:test`

Comprehensive testing workflows with multiple strategies.

**Syntax**:
```bash
/fl:test [--flags] [test-type]
```

**Test Types**:
- **Unit Tests**: Component and function testing
- **Integration Tests**: API and service integration
- **E2E Tests**: Full user workflow validation
- **Performance Tests**: Load and stress testing
- **Security Tests**: Vulnerability and penetration testing

### Documentation Commands

#### `/fl:document`

Intelligent documentation generation and maintenance.

**Syntax**:
```bash
/fl:document [--flags] [scope]
```

**Documentation Types**:
- **API Documentation**: OpenAPI/Swagger generation
- **Component Documentation**: React/Vue component guides
- **Architecture Documentation**: System design and patterns
- **User Guides**: End-user documentation
- **Developer Guides**: Contribution and setup guides

**Example**:
```bash
/fl:document --loop --all-mcp "API endpoints and component library"
```

#### `/fl:explain`

Intelligent code explanation and educational content.

**Syntax**:
```bash
/fl:explain [--flags] [code/concept]
```

**Explanation Modes**:
- **Code Analysis**: Line-by-line code explanation
- **Pattern Explanation**: Design pattern identification and explanation
- **Concept Teaching**: Framework and library concept explanation
- **Best Practices**: Recommendation with rationale

### Quality & Maintenance Commands

#### `/fl:improve`

Intelligent code improvement and refactoring.

**Syntax**:
```bash
/fl:improve [--flags] [target]
```

**Improvement Areas**:
- **Performance**: Optimization and bottleneck elimination
- **Security**: Vulnerability fixing and hardening
- **Maintainability**: Code organization and readability
- **Accessibility**: WCAG compliance and inclusive design
- **Type Safety**: TypeScript improvements and validation

#### `/fl:refactor`

Systematic code refactoring with safety guarantees.

**Syntax**:
```bash
/fl:refactor [--flags] [scope]
```

**Refactoring Types**:
- **Extract Components**: Component extraction and reusability
- **Rename Variables**: Safe renaming across codebase
- **Move Functions**: Code organization and module restructuring
- **Update Patterns**: Modern pattern adoption

### Infrastructure Commands

#### `/fl:deploy`

Intelligent deployment with best practices.

**Syntax**:
```bash
/fl:deploy [--flags] [environment]
```

**Deployment Features**:
- Environment-specific configurations
- Security validation
- Performance monitoring setup
- Rollback planning
- Health check implementation

#### `/fl:monitor`

Observability and monitoring setup.

**Syntax**:
```bash
/fl:monitor [--flags] [metrics-type]
```

**Monitoring Types**:
- **Performance Monitoring**: APM and metrics collection
- **Error Tracking**: Error reporting and alerting
- **User Analytics**: User behavior and experience tracking
- **Infrastructure Monitoring**: Server and service health

## Spike Development Integration

### Automatic Template Selection

Commands automatically detect when Spike development workflow is beneficial:

**Triggers**:
- New component/feature requests
- Framework-specific implementations
- Best practice pattern needs
- Integration requirements

**Selection Process**:
1. **Intent Analysis**: Natural language understanding of requirements
2. **Context Assessment**: Existing codebase and framework detection
3. **Template Matching**: AI-powered template recommendation
4. **Customization**: Parameter-based template adaptation

### Spike Workflow Example

**User Request**: "Add JWT authentication to my Next.js app"

**Automated Process**:
1. üîç **Analysis**: Detects Next.js project, authentication requirement
2. üìö **Library Lookup**: Accesses NextAuth.js specification from catalog
3. üèóÔ∏è **Spike Selection**: Chooses `nextjs-auth-nextauth-credentials` template
4. ‚ö° **Implementation**: Generates authentication code with best practices
5. ‚úÖ **Validation**: Type checking, security validation, test creation
6. üìñ **Documentation**: Updates API docs and user guides

**Generated Files**:
- `pages/api/auth/[...nextauth].ts` - NextAuth configuration
- `lib/auth.ts` - Authentication utilities
- `middleware.ts` - Route protection
- `components/LoginForm.tsx` - Login component
- `__tests__/auth.test.ts` - Authentication tests

### SuperClaude Parameter Integration

All /fl: commands support full SuperClaude parameter bypass:

#### Core Parameters
- `--loop`: Iterative refinement with quality validation
- `--wave-mode`: Multi-stage implementation strategy
- `--delegate`: Parallel task processing and delegation
- `--until-perfect`: Quality gates and validation loops
- `--ultrathink`: Deep analysis and architectural thinking
- `--all-mcp`: Complete MCP server integration

#### Thinking Parameters
- `--think`: Enhanced analysis and reasoning
- `--think-hard`: Deep architectural analysis
- `--uc`: Ultra-compressed token-efficient mode

#### Validation Parameters
- `--validate`: Pre-operation validation and safety checks
- `--safe-mode`: Conservative operation with maximum validation

#### Scope Parameters
- `--scope file|module|project`: Operation scope control
- `--focus performance|security|quality`: Targeted optimization areas

## Integration Examples

### React Component Development

```bash
# Create drag-and-drop component with accessibility
/fl:implement --loop --wave-mode --all-mcp "React drag-and-drop file uploader with progress, accessibility, and TypeScript"
```

**Automatic Integration**:
- React DnD library specification lookup
- Accessibility patterns from WCAG guidelines
- TypeScript type definitions
- Testing setup with React Testing Library
- Storybook documentation generation

### API Development

```bash
# Build FastAPI service with authentication
/fl:implement --delegate --until-perfect "FastAPI REST API with JWT auth, PostgreSQL, and OpenAPI docs"
```

**Spike Templates Applied**:
- `fastapi-jwt-auth` - JWT authentication setup
- `fastapi-sqlalchemy-postgres` - Database integration
- `fastapi-openapi-tags` - API documentation
- `fastapi-pytest-minimal` - Testing framework

### Full-Stack Application

```bash
# Complete application development
/fl:implement --wave-mode --ultrathink --all-mcp "Next.js e-commerce app with Stripe payments, user auth, and admin dashboard"
```

**Multi-Wave Implementation**:
1. **Wave 1**: Project setup and authentication
2. **Wave 2**: Product catalog and shopping cart
3. **Wave 3**: Payment integration and checkout
4. **Wave 4**: Admin dashboard and analytics
5. **Wave 5**: Testing, optimization, and deployment

## Quality Assurance

### Automated Validation

Every /fl: command includes:

**Code Quality**:
- TypeScript type checking
- ESLint/Prettier formatting
- Security vulnerability scanning
- Performance optimization verification

**Testing**:
- Unit test generation
- Integration test setup
- E2E test scenarios
- Performance benchmarking

**Documentation**:
- API documentation generation
- Component documentation updates
- Usage example creation
- Migration guide updates

### Continuous Improvement

**Learning Loop**:
1. Implementation success tracking
2. User feedback integration
3. Template effectiveness analysis
4. Best practice evolution

**Quality Metrics**:
- Code coverage percentages
- Performance benchmarks
- Security scan results
- User satisfaction scores

## Error Handling & Recovery

### Intelligent Error Detection

**Compilation Errors**:
- TypeScript type errors with fix suggestions
- Import/export resolution issues
- Syntax error detection and correction

**Runtime Errors**:
- Common pattern mistakes
- Performance anti-patterns
- Security vulnerabilities

**Integration Errors**:
- Dependency conflicts
- Version compatibility issues
- Configuration mismatches

### Automatic Recovery

**Rollback Capabilities**:
- Safe operation rollback
- Incremental change application
- Conflict resolution strategies

**Alternative Approaches**:
- Fallback template selection
- Alternative implementation patterns
- Manual intervention guidance

## Performance Optimization

### Intelligent Caching

**Template Caching**:
- Frequently used template pre-loading
- Parameter-based template variants
- User preference learning

**Library Specification Caching**:
- Local specification storage
- Version-aware caching
- Incremental updates

### Parallel Processing

**Concurrent Operations**:
- Multi-file processing
- Parallel validation
- Distributed template application

**Resource Management**:
- Memory usage optimization
- CPU usage balancing
- Network request optimization

## Security Considerations

### Secure Defaults

**Authentication Patterns**:
- Secure session management
- CSRF protection
- Input validation

**API Security**:
- Rate limiting implementation
- Input sanitization
- SQL injection prevention

### Vulnerability Scanning

**Automated Scanning**:
- Dependency vulnerability checking
- Code pattern security analysis
- Configuration security validation

**Compliance Checking**:
- OWASP Top 10 validation
- Industry standard compliance
- Regulatory requirement checking

## Advanced Usage

### Custom Template Creation

**Template Development**:
- Custom Spike template creation
- Parameter definition and validation
- Best practice integration

**Template Sharing**:
- Community template contributions
- Template version management
- Quality validation processes

### Integration with CI/CD

**Pipeline Integration**:
- GitHub Actions workflow generation
- Quality gate automation
- Deployment pipeline creation

**Monitoring Integration**:
- Performance monitoring setup
- Error tracking implementation
- Analytics and reporting

## Troubleshooting

### Common Issues

**Template Selection**:
- Ambiguous requirements resolution
- Template compatibility checking
- Parameter validation errors

**Code Generation**:
- Naming conflict resolution
- Import path correction
- Type definition conflicts

### Debugging Tools

**Verbose Logging**:
- Detailed operation tracking
- Error context preservation
- Performance profiling data

**Diagnostic Commands**:
- `/fl:debug` - Diagnostic information
- `/fl:validate` - Pre-operation validation
- `/fl:status` - Current operation status

## Best Practices

### Effective Usage

**Requirement Specification**:
- Clear, specific requirements
- Context and constraint definition
- Success criteria specification

**Iterative Development**:
- Use `--loop` for refinement
- Incremental feature addition
- Continuous validation

### Team Collaboration

**Shared Standards**:
- Team-wide template adoption
- Consistent coding patterns
- Shared quality standards

**Knowledge Sharing**:
- Template usage documentation
- Best practice sharing
- Continuous learning

---

**/fl: Commands Documentation v0.9.7 - Enhanced with SuperClaude Integration**